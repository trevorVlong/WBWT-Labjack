classdef LabjackT7 < handle
    %LABJACKT7 class for interfacing with a labjack T7 and configuring it for various tasks. 
    %   Detailed explanation goes here
    
    properties(SetAccess=private,GetAccess=public)
        % settings for .NET assembly, private because the user won't need them
        ljmAsm 
        LJM_CONSTANTS
        handle
        LJMASM 
        TIME    
    end
    
    properties(Access = public)
    % data and other relevant properties for data collection and signal output from the labjack  
        SCANRATE
        ScanNum
        clock_roll_value 

    % AIN tracking
        AINChannels = []
        DIOInChannels = []
        ChannelIn = []
        numIN
        ScanList
        ScanListNames
        NETScanList
        Types

        DeviceBacklog
        LJMBacklog
        
        SCAN_RATE = 10; % scan rate in Hz
        STREAM_RESOLUTION_INDEX = 0; % 0 for fast, 8 for accurate but slow
        
    end
    
    methods
        
        function setup(obj)
            %LJBOX Construct an instance of this class
            %   Detailed explanation goes here
            obj.LJMASM = NET.addAssembly('Labjack.LJM');
            obj.TIME = obj.LJMASM.AssemblyHandle.GetType('LabJack.LJM+CONSTANTS');
            obj.LJM_CONSTANTS = System.Activator.CreateInstance(obj.TIME);
            
        end
        
        function connect(obj)
            % connects to a labjack T7 device
            % *** NOTE to set this up for multiple devices****
            [ljmError, obj.handle] = LabJack.LJM.OpenS('T7','ANY','ANY',0);
            
        end

        function configurePWMOuput(obj)
            % CONFIGUREPWMOUTPUT sets up the labjack to ouput a pwm signal and sets the default signal to 10ms.
            % The class is based of the example provided at https://support.labjack.com/docs/13-2-2-pwm-out-t-series-datasheet 
            %
            % sets up and starts a PWM output from Labjack, this can be changed before 
            % the start of any stream of data, and will continue until changed again
            %
            % ***NOTE***  best practice is to always set motors back to 0 after each run
            % otherwise, it is likely that they will burn out if at high RPMs
            % 
            % this setup function will always intialize a motor at PWM = 1000, function below
            % will change the actual
            %
            % channel is always outputting PWM signal after DIO0,EF_ENABLE,1 line
            name = "DIO0"; % channel 

            % set Clock0 roll value for 50 Hz output signal, T7 clock runs at 160Mhz
            obj.clock_roll_value = 160000; % length of the pwm signal  
            LabJack.LJM.eWriteName(obj.handle,"DIO_EF_CLOCK0_ENABLE",0);
            LabJack.LJM.eWriteName(obj.handle,'DIO_EF_CLOCK0_DIVISOR',1);
            LabJack.LJM.eWriteName(obj.handle,"DIO_EF_CLOCK0_ROLL_VALUE",obj.clock_roll_value)
            LabJack.LJM.eWriteName(obj.handle,"DIO_EF_CLOCK0_ENABLE",1);
            
            % set intitial value to PWM = 1000
            % set low value
            LabJack.LJM.eWriteName(obj.handle, sprintf("%s_EF_ENABLE",name),0); 	%// Disable the EF system for initial configuration
            LabJack.LJM.eWriteName(obj.handle, sprintf("%s_EF_INDEX",name), 0); 	%// Configure EF system for PWM
            LabJack.LJM.eWriteName(obj.handle, sprintf("%s_EF_OPTIONS", name),000); 	%// Configure what clock source to use Clock0
            LabJack.LJM.eWriteName(obj.handle, sprintf("%s_EF_CONFIG_A",name), 80*1000); 	%// Configure duty cycle to be slightly less than 1000
            LabJack.LJM.eWriteName(obj.handle, sprintf("%s_EF_ENABLE",name), 1); 	%// Enable the EF system, PWM wave is now being outputted
            
            %DUTY cycle info
            % 80000 ~ 1000 PWM, 16000 ~ 2000 PWM (slightly less)
            % states 1 = output_high, 0 = output_low
            %LabJack.LJM.eWriteName(handle,name,state)
        end
 
% set up or changre PWM out        
        function setPWM(obj,PWM)
            %SETPWM sets the pwm output signal to the desired value on DIO0
            % changes the PWM output from the labjack to specified value
            % channel is streaming the whole time
             
            LabJack.LJM.eWriteName(obj.handle,"DIO0_EF_ENABLE",0);
            LabJack.LJM.eWriteName(obj.handle,"DIO0_EF_INDEX", 0); 	%// Configure EF system for PWM
            LabJack.LJM.eWriteName(obj.handle, "DIO0_EF_OPTIONS",000); 	%// Configure what clock source to use: Clock0
            LabJack.LJM.eWriteName(obj.handle, "DIO0_EF_CONFIG_A", 80*PWM);
            LabJack.LJM.eWriteName(obj.handle,"DIO0_EF_ENABLE",1);
        end    

        function obj = setupCounter(obj,port_name)
            % SETDIOCOUNTER configures digital counter port. Default
            % counter port is DIO18 (CIO2) which is a high-speed counter
            % port that is always active on the T7. Other viable ports are
            % CIO0-3 (DIO16-DIO19). 
            %
            % reference: https://support.labjack.com/docs/13-2-8-high-speed-counter-t-series-datasheet

            arguments
                obj (1,1) LabjackT7
                port_name (1,1) string {mustBeTextScalar,mustBeMember(port_name,["DIO16","DIO17","DIO18","DIO19"])} = "DIO18"
            end
            
            read_register = sprintf("%s_EF_READ_A",port_name);
            if ~ismember(port_name,obj.DIOInChannels)
                try
                    LabJack.LJM.eWriteName(obj.handle,sprintf('%s_EF_ENABLE',port_name),0);
                    LabJack.LJM.eWriteName(obj.handle,sprintf('%s_EF_INDEX',port_name),7);
                    LabJack.LJM.eWriteName(obj.handle,sprintf('%s_EF_ENABLE',port_name),1);
                    
                    obj.DIOInChannels = [obj.DIOInChannels, read_register];
                catch e 
                    disp(e);
                end
            else
                warning("%s is already a configured port",port_name)
            end

        end


        function obj = AINSingleEnded(obj, channel_name)
            % CONFIGUREAINSINGLEENDED configures selected AIN channels to read +/- 10V signals. 
            % 
            % 
            % 
            numFrames = 4;
            
            aNames = NET.createArray('System.String', numFrames);
            aNames(1) = sprintf('%s_NEGATIVE_CH',channel_name);
            aNames(2) = sprintf('%s_RANGE',channel_name);
            aNames(3) = sprintf('%s_RESOLUTION_INDEX',channel_name);
            aNames(4) = sprintf('%s_SETTLING_US',channel_name);
            aValues = NET.createArray('System.Double', numFrames);
            aValues(1) = 199;
            aValues(2) = 10;
            aValues(3) = 1;
            aValues(4) = 1;

            LabJack.LJM.eWriteNames(obj.handle, numFrames, aNames, aValues, 0);
            obj.AINChannels = [obj.AINChannels, channel_name];
            
            disp('----------------------------------------------------------')
            disp('Set configuration:');
            for i = 1:numFrames
                disp(['  ' char(aNames(i)) ': ' num2str(aValues(i))])
            end
            disp('----------------------------------------------------------')
            
        end

        function obj = multiAINSingleEnded(obj,channel_names)
            %MULTIAINSINGLENDED configures all channels in channel_names to read single-ended +/-10V signals
            for channel_num = 1:length(channel_names)
                % confiure channel and add to tracking list, otherwise display error
                try
                    obj.AINSingleEnded(channel_names(channel_num));
                catch e 
                    disp(e);
                end
            end
        end
        
        function obj = clearScanList(obj)
            % reset all trackers for which channels are going to be read
            obj.AINChannels = [];
            obj.DIOInChannels = [];
            obj.ChannelIn = [];
        
        end
        
        function obj = configureStream(obj,scan_rate)
            % configure .NET arrays / labjack for scanning. Stores some .NET arrays for sending to labjack
            % set scan rate in Hz [1-60000]. Note that for some reason
            % stream burst only likes to operate between 500Hz and 1000Hz.
            % Really couldn't explain why
            arguments
                obj LabjackT7
                scan_rate (1,1) double {mustBeInteger,mustBeGreaterThan(scan_rate,0)} = 1000 
            end
            

            % set the scan list based on DIO / AIN channels in
            % configuration list
            obj.ChannelIn = [obj.AINChannels, obj.DIOInChannels];
            obj.numIN = length(obj.ChannelIn);

            % set scan rate in Hz [1-60000] calculated as desired scan rate * number of ports to read
            obj.SCANRATE = scan_rate*obj.numIN;
            
            % create NET arrays, fill out ScanList
            obj.NETScanList = NET.createArray('System.Int32',obj.numIN);
            obj.Types = NET.createArray('System.Int32',obj.numIN);
            obj.ScanListNames = NET.createArray('System.String',obj.numIN);
            for idx = 1:obj.numIN
                obj.ScanListNames(idx) = sprintf("%s",obj.ChannelIn(idx));
            end
            
            % get addresses from names
            LabJack.LJM.NamesToAddresses(obj.numIN,obj.ScanListNames,obj.NETScanList,obj.Types)

            % set stream resolution (1 for speed, 8 for accuracy)
            LabJack.LJM.eWriteName(obj.handle,'STREAM_RESOLUTION_INDEX',obj.STREAM_RESOLUTION_INDEX)
        end
            
            


        function obj = setReadRegisters(obj)
            % SETREADREGISTERS sets the ChannelIn regisers based on the
            % the channels in DIOIN and AIN. Saves these to class
            % properties which are used to configure reads from the labjack
            % register

            obj.clearScanList()
            
            % set channelIn from AIN, DIOIn channels
            obj.ChannelIn = [obj.AINChannels, obj.DIOInChannels];
            obj.numIN = length(obj.ChannelIn);
            
            % create NET arrays for LJM handling
            obj.NETScanList = NET.createArray('System.Int32',obj.numIN);
            obj.Types = NET.createArray('System.Int32',obj.numIN);
            obj.ScanListNames = NET.createArray('System.String',obj.numIN);
            for idx = 1:obj.numIN
                obj.ScanListNames(idx) = sprintf("%s",obj.ChannelIn(idx));
            end
            LabJack.LJM.NamesToAddresses(obj.numIN,obj.ScanListNames,obj.NETScanList,obj.Types)
            LabJack.LJM.eWriteName(obj.handle,'STREAM_RESOLUTION_INDEX',1)

        end

        function data = read(obj)
            % READ reads a single point from all registers in ChannelIn.
            % Returns as an Nx1 vector of values.
            net_data = NET.createArray('System.Double',obj.numIN);
            data = zeros([obj.numIN,1]);
            try
                LabJack.LJM.eReadNames(obj.handle,obj.numIN,obj.ScanListNames,net_data,0);
            catch e
                disp(e)
            end

            for idx = 1:obj.numIN
                data(idx) = net_data(idx);
            end
        end

        function data = timedRead(obj,scan_time)
            %TIMEDREAD reads registers in a loop  at the specified
            %obj.SCANRATE and returns an Nx(scan_rate*scan_time) matrix of
            %values. Not incredibly precise but should be OK for most
            %relatively slow measurements for short periods of time
            timeout = 1.5*scantime;
            % pre-allocate table space
            N_points = scan_time*obj.SCANRATE;
            dt_desired = 1/obj.SCANRATE;
            data_table = zeros([obj.numIN,N_points]);
            
            tic;
            current_idx = 1;
            time_last = toc;
            dt = 0;
            while time_now <= scan_time

                % get current time, calculate dt
                time_now = toc;
                dt = time_now - time_last;

                % special case for t=0
                if current_idx == 1
                    data_table(:,current_idx) = obj.read();
                    current_idx = current_idx + 1;
                    time_last = time_now;
                    
                elseif dt >= dt_desired
                    data_table(:,current_idx) = obj.read();
                    current_idx = current_idx + 1;
                    time_last = time_now;
                end
                
                % hard kill after a length of time
                if time_now > timeout
                    break
                end

            end
            

        end

        function data = streamBurst(obj,scantime_in_s)
            % STREAMBURST sets the labjack to record data on all active channels for a set amount of time and 
            % the rate in class settings. The total number of measurements will  
            %
            % INPUTS:
            % :scantime int: [s] time to scan 
            %

            % set up scan rate / storage .NET array, create data array
            scanNum = obj.SCANRATE*scantime_in_s;
            netdata = NET.createArray('System.Double',scanNum*obj.numIN);

            % run scan
            fprintf('-----------------------------------------------------------------------\n');
            fprintf('Running stream burst with a scantime of %3.1d s and SCANRATE %i...\n',scantime_in_s,obj.SCANRATE);
            fprintf('-----------------------------------------------------------------------\n');
            tic;
            [err, ~] = LabJack.LJM.StreamBurst(obj.handle, obj.numIN, obj.NETScanList, obj.SCANRATE, scanNum, netdata);

            toc
            % reshape data for export as an MxN vector where M is number of read channels and N is the number of scans for those channels
            for idx = 1:scanNum
                data(idx) = netdata(idx);
            end
            data = reshape(data,obj.numIN,[]);
            
            fprintf('Stream Complete\n');
            fprintf('Error Status: %s \n',err)
            fprintf('-----------------------------------------------------------------------\n')
            fprintf('-----------------------------------------------------------------------\n')
        end
        
       
    end
end

